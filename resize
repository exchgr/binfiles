#!/usr/bin/env ruby

require 'parallel'
require 'optparse'

DIMENSIONS_DELIMITER="x"

def parse_options(options)
  {}.tap do |args|
    OptionParser.new do |opts|
      opts.banner =
"""resize images to a constant aspect ratio

Centers images on the canvas and adds a white letterbox.
Thanks to Instagram's restrictive posting interface
for inspiring this utility.

Usage: resize <options> <file1> [<file2> ...]

Example
=======

Files:
1.png: 6000x4000
2.png: 4000x6000

Command:
resize -w 4 -h 5 *.png

Yields:
out/1.png: 6000x7500
out/2.png: 4800x6000

Options
=======

"""

      {
        w: :width,
        h: :height,
      }.each do |short, long|
        opts.on(
          "-#{short} <ratio_#{long}>",
          "--#{long} <ratio_#{long}>",
          "The aspect ratio's #{long}",
          Float
        )
      end

      opts.on(
        "--help",
        "Print this help text"
      ) do
        puts opts
        exit
      end
    end.parse!(options, into: args)
  end
end

OPTS = parse_options(ARGV)

def identify_dimensions(filename)
  `identify -format "%w#{DIMENSIONS_DELIMITER}%h" "#{filename}"`
end

def dimensions_to_s(dimensions)
  "#{dimensions[:width]}#{DIMENSIONS_DELIMITER}#{dimensions[:height]}"
end

def convert_dimensions(file)
  "convert \"#{file[:filename]}\" " +
    "-resize #{dimensions_to_s(file[:dimensions])} " +
    "-background White " +
    "-gravity center " +
    "-extent #{dimensions_to_s(file[:dimensions])} " +
    "\"out/#{file[:filename]}\" && " +

  "exiftool " +
    "-tagsFromFile \"#{file[:filename]}\" " +
    "-All:All " +
    "-IFD1:All " +
    "-overwrite_original " +
    "\"out/#{file[:filename]}\""
end

# yields this schema:
# {
#   filename: "filename",
#   dimensions: {
#     width: 1234,
#     height: 1234
#   }
# }
def dimensions(filename)
  {filename: filename}.merge(dimensions: Hash[
    [:width, :height].zip(
      identify_dimensions(filename)
      .split(DIMENSIONS_DELIMITER)
      .map(&:to_i)
    )
  ]).tap(&method(:puts))
end

def max_dimension(dimensions)
  dimensions.key(dimensions.values.max)
end

def min_dimension(dimensions)
  dimensions.key(dimensions.values.min)
end

def conversion_factor(key)
  {
    width: OPTS[:height]/OPTS[:width],
    height: OPTS[:width]/OPTS[:height]
  }[key]
end

def new_dimensions(file)
  file.merge({
    dimensions: file[:dimensions].merge({
      :"#{min_dimension(file[:dimensions])}" => (
        file[:dimensions][max_dimension(file[:dimensions])] *
        conversion_factor(max_dimension(file[:dimensions]))
      ).to_i
    })
  })
end

Parallel.each(
  ARGV
  .map(&method(:dimensions))
  .map(&method(:new_dimensions))
  .map(&method(:convert_dimensions))
) do |command|
  command
    .tap(&method(:puts))
    .tap(&method(:`))
end
